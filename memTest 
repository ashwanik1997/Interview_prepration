#ifndef MEMBRANE_H
#define MEMBRANE_H

#include "stm32f4xx_hal.h"

typedef enum {
    MEMBRANE_KEY_NONE = 0,
    MEMBRANE_KEY_M1,
    MEMBRANE_KEY_M2,
    MEMBRANE_KEY_M3,
    MEMBRANE_KEY_M4,
    MEMBRANE_KEY_C1,
    MEMBRANE_KEY_C2,
    MEMBRANE_KEY_C3,
    MEMBRANE_KEY_C4,
    MEMBRANE_KEY_HLP,
    MEMBRANE_KEY_ENT
} MembraneKey_t;

typedef struct {
    MembraneKey_t key;
    bool pressed;
} MembraneEvent_t;

void Membrane_Init(void);
MembraneKey_t Membrane_Scan(void);
bool Membrane_GetEvent(MembraneEvent_t* event);
void Membrane_ISR_Handler(uint16_t GPIO_Pin);

#endif // MEMBRANE_H

#include "membrane.h"

// Hardware Configuration
#define COL_PORT GPIOD
#define COL1_PIN GPIO_PIN_0
#define COL2_PIN GPIO_PIN_1
#define COL3_PIN GPIO_PIN_2
#define COL4_PIN GPIO_PIN_3

#define ROW_PORT GPIOG
#define ROW1_PIN GPIO_PIN_0
#define ROW2_PIN GPIO_PIN_1
#define ROW3_PIN GPIO_PIN_2

static const MembraneKey_t keymap[3][4] = {
    {MEMBRANE_KEY_M1, MEMBRANE_KEY_M2, MEMBRANE_KEY_M3, MEMBRANE_KEY_M4},
    {MEMBRANE_KEY_C1, MEMBRANE_KEY_C2, MEMBRANE_KEY_C3, MEMBRANE_KEY_C4},
    {MEMBRANE_KEY_HLP, MEMBRANE_KEY_ENT, MEMBRANE_KEY_NONE, MEMBRANE_KEY_NONE}
};

static MembraneEvent_t eventQueue[10];
static volatile uint8_t queueHead = 0;
static volatile uint8_t queueTail = 0;

void Membrane_Init(void) {
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    // Enable GPIO clocks
    __HAL_RCC_GPIOD_CLK_ENABLE();
    __HAL_RCC_GPIOG_CLK_ENABLE();

    // Configure columns as outputs
    GPIO_InitStruct.Pin = COL1_PIN | COL2_PIN | COL3_PIN | COL4_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(COL_PORT, &GPIO_InitStruct);

    // Configure rows as inputs with interrupts
    GPIO_InitStruct.Pin = ROW1_PIN | ROW2_PIN | ROW3_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING | GPIO_MODE_IT_RISING;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(ROW_PORT, &GPIO_InitStruct);

    // Initialize columns to high (inactive)
    HAL_GPIO_WritePin(COL_PORT, COL1_PIN | COL2_PIN | COL3_PIN | COL4_PIN, GPIO_PIN_SET);
}

MembraneKey_t Membrane_Scan(void) {
    GPIO_PinState rowState;
    uint8_t col;

    for (col = 0; col < 4; col++) {
        // Activate current column
        HAL_GPIO_WritePin(COL_PORT, (COL1_PIN << col), GPIO_PIN_RESET);
        
        // Short delay for stabilization
        for(volatile int i = 0; i < 10; i++);

        // Check rows
        rowState = HAL_GPIO_ReadPin(ROW_PORT, ROW1_PIN);
        if (rowState == GPIO_PIN_RESET) {
            HAL_GPIO_WritePin(COL_PORT, (COL1_PIN << col), GPIO_PIN_SET);
            return keymap[0][col];
        }

        rowState = HAL_GPIO_ReadPin(ROW_PORT, ROW2_PIN);
        if (rowState == GPIO_PIN_RESET) {
            HAL_GPIO_WritePin(COL_PORT, (COL1_PIN << col), GPIO_PIN_SET);
            return keymap[1][col];
        }

        rowState = HAL_GPIO_ReadPin(ROW_PORT, ROW3_PIN);
        if (rowState == GPIO_PIN_RESET) {
            HAL_GPIO_WritePin(COL_PORT, (COL1_PIN << col), GPIO_PIN_SET);
            return keymap[2][col];
        }

        // Deactivate column
        HAL_GPIO_WritePin(COL_PORT, (COL1_PIN << col), GPIO_PIN_SET);
    }

    return MEMBRANE_KEY_NONE;
}

void Membrane_ISR_Handler(uint16_t GPIO_Pin) {
    MembraneKey_t key = Membrane_Scan();
    if (key != MEMBRANE_KEY_NONE) {
        uint8_t nextTail = (queueTail + 1) % 10;
        if (nextTail != queueHead) {
            eventQueue[queueTail].key = key;
            eventQueue[queueTail].pressed = (HAL_GPIO_ReadPin(ROW_PORT, GPIO_Pin) == GPIO_PIN_RESET);
            queueTail = nextTail;
        }
    }
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
}

bool Membrane_GetEvent(MembraneEvent_t* event) {
    if (queueHead == queueTail) {
        return false;
    }
    *event = eventQueue[queueHead];
    queueHead = (queueHead + 1) % 10;
    return true;
}

#ifndef MEMBRANE_MAIN_H
#define MEMBRANE_MAIN_H

#include "os.h"
#include "membrane.h"

// Task configuration
#define MEMBRANE_TASK_PRIO       10
#define MEMBRANE_TASK_STK_SIZE  256

extern OS_TCB  MembraneTCB;
extern CPU_STK MembraneStk[MEMBRANE_TASK_STK_SIZE];

void MembraneMain_Init(OS_ERR *p_err);
void MembraneMain_Start(OS_ERR *p_err);
MembraneKey_t MembraneMain_GetKey(OS_TICK timeout, OS_ERR *p_err);
bool MembraneMain_GetEvent(MembraneEvent_t *event, OS_TICK timeout, OS_ERR *p_err);

#endif // MEMBRANE_MAIN_H

#include "membrane_main.h"
#include "membrane.h"
#include "os.h"

/* Static uC/OS-III objects */
static OS_Q        MembraneQ;            // Key event queue
static OS_MUTEX    MembraneMutex;        // Membrane scan mutex
static OS_FLAG_GRP MembraneFlags;        // Key event flags

/* Task Control Block and Stack */
OS_TCB  MembraneTCB;
CPU_STK MembraneStk[MEMBRANE_TASK_STK_SIZE];

/**
 * @brief Membrane keypad task function
 * @param p_arg Unused parameter
 */
static void Membrane_Task(void *p_arg) {
    OS_ERR      err;
    MembraneEvent_t event;
    CPU_TS      ts;
    OS_FLAGS    flags;

    (void)p_arg;  // Prevent unused variable warning

    while (DEF_TRUE) {
        /* Wait for key event flag */
        flags = OSFlagPend(&MembraneFlags,
                          (OS_FLAGS)1,
                          0,
                          OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME,
                          &ts,
                          &err);

        if (err == OS_ERR_NONE) {
            /* Protect scan operation with mutex */
            OSMutexPend(&MembraneMutex, 0, OS_OPT_PEND_BLOCKING, 0, &err);
            
            /* Scan the membrane keypad */
            MembraneKey_t key = Membrane_Scan();
            bool pressed = (flags & 1);
            
            OSMutexPost(&MembraneMutex, OS_OPT_POST_NONE, &err);

            if (key != MEMBRANE_KEY_NONE) {
                /* Prepare and post event to queue */
                event.key = key;
                event.pressed = pressed;

                OSQPost(&MembraneQ,
                       &event,
                       sizeof(MembraneEvent_t),
                       OS_OPT_POST_FIFO,
                       &err);
            }
        }
    }
}

/**
 * @brief Initialize membrane keypad OS resources
 * @param p_err Pointer to error code
 */
void MembraneMain_Init(OS_ERR *p_err) {
    /* Initialize hardware layer */
    Membrane_Init();
    
    /* Create uC/OS-III synchronization objects */
    OSFlagCreate(&MembraneFlags,
                "Membrane Flags",
                0,
                p_err);
    if (*p_err != OS_ERR_NONE) return;

    OSMutexCreate(&MembraneMutex,
                 "Membrane Mutex",
                 p_err);
    if (*p_err != OS_ERR_NONE) return;

    OSQCreate(&MembraneQ,
             "Membrane Queue",
             KEYPAD_QUEUE_SIZE,
             p_err);
}

/**
 * @brief Start membrane keypad scanning task
 * @param p_err Pointer to error code
 */
void MembraneMain_Start(OS_ERR *p_err) {
    OSTaskCreate(&MembraneTCB,
                "Membrane Task",
                Membrane_Task,
                0,
                MEMBRANE_TASK_PRIO,
                &MembraneStk[0],
                MEMBRANE_TASK_STK_SIZE / 10,
                MEMBRANE_TASK_STK_SIZE,
                0,
                0,
                0,
                (OS_OPT_TASK_STK_CLR | OS_OPT_TASK_STK_CHK),
                p_err);
}

/**
 * @brief Get a pressed key (blocks until key press or timeout)
 * @param timeout Timeout in ticks (0=no wait, OS_OPT_PEND_BLOCKING=wait forever)
 * @param p_err Pointer to error code
 * @return MembraneKey_t Pressed key or MEMBRANE_KEY_NONE if timeout
 */
MembraneKey_t MembraneMain_GetKey(OS_TICK timeout, OS_ERR *p_err) {
    MembraneEvent_t *p_event;
    MembraneKey_t    key = MEMBRANE_KEY_NONE;

    p_event = OSQPend(&MembraneQ,
                     timeout,
                     OS_OPT_PEND_BLOCKING,
                     sizeof(MembraneEvent_t),
                     0,
                     p_err);

    if (*p_err == OS_ERR_NONE && p_event->pressed) {
        key = p_event->key;
    }

    return key;
}

/**
 * @brief Get complete key event (press/release)
 * @param p_event Pointer to store event data
 * @param timeout Timeout in ticks
 * @param p_err Pointer to error code
 * @return true if event available, false if timeout
 */
bool MembraneMain_GetEvent(MembraneEvent_t *p_event, OS_TICK timeout, OS_ERR *p_err) {
    MembraneEvent_t *p_qevent;
    
    p_qevent = OSQPend(&MembraneQ,
                      timeout,
                      OS_OPT_PEND_BLOCKING,
                      sizeof(MembraneEvent_t),
                      0,
                      p_err);

    if (*p_err == OS_ERR_NONE) {
        *p_event = *p_qevent;
        return true;
    }
    
    return false;
}

/**
 * @brief Membrane keypad interrupt service routine
 * @note This should be called from HAL_GPIO_EXTI_Callback
 */
void MembraneMain_ISR_Handler(uint16_t GPIO_Pin) {
    OS_ERR err;
    CPU_SR_ALLOC();

    /* Determine event type (press=1, release=0) */
    OS_FLAGS flags = (HAL_GPIO_ReadPin(ROW_PORT, GPIO_Pin) == GPIO_PIN_RESET) ? 1 : 0;

    /* Post flag atomically */
    CPU_CRITICAL_ENTER();
    OSFlagPost(&MembraneFlags,
              flags,
              OS_OPT_POST_FLAG_SET,
              &err);
    CPU_CRITICAL_EXIT();
}

// In stm32f4xx_it.c
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
    if (GPIO_Pin == ROW1_PIN || GPIO_Pin == ROW2_PIN || GPIO_Pin == ROW3_PIN) {
        MembraneMain_ISR_Handler(GPIO_Pin);
        Membrane_ISR_Handler(GPIO_Pin); // Hardware layer handler
    }
}

// Non-blocking event check
OS_ERR err;
MembraneEvent_t event;

while(MembraneMain_GetEvent(&event, 0, &err)) {
    if(event.pressed) {
        // Key press handling
        switch(event.key) {
            case MEMBRANE_KEY_M1:
                printf("M1 pressed\n");
                StartMotor();
                break;
                
            case MEMBRANE_KEY_C1:
                printf("C1 pressed\n");
                AdjustParameter(1);
                break;
        }
    } else {
        // Key release handling
        switch(event.key) {
            case MEMBRANE_KEY_M1:
                printf("M1 released\n");
                StopMotor();
                break;
                
            case MEMBRANE_KEY_ENT:
                printf("Enter released\n");
                FinalizeEntry();
                break;
        }
    }
}

if(err != OS_ERR_NONE && err != OS_ERR_TIMEOUT) {
    // Handle serious errors
    HandleKeypadError(err);
}

void ProcessKeypadInput(void) {
    static uint32_t last_key_time = 0;
    OS_ERR err;
    
    // 1. First check for any pending events (non-blocking)
    MembraneEvent_t event;
    while(MembraneMain_GetEvent(&event, 0, &err)) {
        if(event.pressed) {
            last_key_time = OS_TS_GET();
            HandleKeyPress(event.key);
        } else {
            HandleKeyRelease(event.key);
        }
    }
    
    // 2. If no recent activity, do blocking wait
    if(OS_TS_GET() - last_key_time > 500) { // 500ms since last key
        MembraneKey_t key = MembraneMain_GetKey(100, &err);
        if(err == OS_ERR_NONE) {
            last_key_time = OS_TS_GET();
            HandleKeyPress(key);
        }
    }
}

void HandleKeyPress(MembraneKey_t key) {
    switch(key) {
        case MEMBRANE_KEY_M1:
            StartCriticalFunction();
            break;
            
        case MEMBRANE_KEY_C2:
            ToggleSetting(SETTING_2);
            break;
            
        // ... other key handlers
    }
}

void HandleKeyRelease(MembraneKey_t key) {
    switch(key) {
        case MEMBRANE_KEY_M1:
            CompleteCriticalFunction();
            break;
            
        case MEMBRANE_KEY_ENT:
            SaveCurrentConfiguration();
            break;
    }
}

void AppTaskKeypad(void *p_arg) {
    OS_ERR err;
    (void)p_arg;
    
    while(1) {
        // Blocking wait for key press (with 200ms timeout)
        MembraneKey_t key = MembraneMain_GetKey(200, &err);
        
        if(err == OS_ERR_NONE) {
            // Process key press
            switch(key) {
                case MEMBRANE_KEY_M1:
                    if(CheckSystemReady()) {
                        StartProcess();
                    } else {
                        ShowError("System not ready");
                    }
                    break;
                    
                case MEMBRANE_KEY_HLP:
                    ShowContextHelp();
                    break;
                    
                case MEMBRANE_KEY_ENT:
                    if(ValidateInput()) {
                        CommitTransaction();
                    }
                    break;
            }
            
            // Optional: Debounce delay
            OSTimeDly(20, OS_OPT_TIME_DLY, &err);
        }
        else if(err == OS_ERR_TIMEOUT) {
            // Timeout occurred - do background processing
            UpdateDisplay();
            CheckBattery();
        }
        else {
            // Handle other errors
            RecoverFromKeypadError();
        }
    }
}