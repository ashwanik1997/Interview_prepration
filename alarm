#ifndef ALARM_AUDIO_H
#define ALARM_AUDIO_H

#include "stm32f4xx_hal.h"
#include "os.h"

// Alarm priority levels
typedef enum {
    ALARM_PRIORITY_NONE = 0,
    ALARM_PRIORITY_LOW,
    ALARM_PRIORITY_MEDIUM,
    ALARM_PRIORITY_HIGH
} AlarmPriority_t;

// Public API
void Alarm_Init(TIM_HandleTypeDef *htim);
void Alarm_Start(AlarmPriority_t priority);
void Alarm_Stop(void);

// Configuration
#define ALARM_TIMER_CHANNEL      TIM_CHANNEL_3
#define BUZZER_TASK_STACK_SIZE   256
#define BUZZER_TASK_PRIORITY     10

#endif // ALARM_AUDIO_H


#include "alarm_audio.h"
#include <string.h>

// Module-level variables
static TIM_HandleTypeDef *alarm_htim = NULL;
static AlarmPriority_t current_priority = ALARM_PRIORITY_NONE;

// Alarm state machine
typedef enum {
    STATE_IDLE,
    STATE_PLAYING,
    STATE_SPACING,
    STATE_INTER_BURST
} AlarmState_t;

static AlarmState_t state = STATE_IDLE;
static uint8_t pulseIndex = 0;

// Frequency definitions for each priority level
static const uint16_t low_harmonics[]    = { 700 };
static const uint16_t medium_harmonics[] = { 900, 1800, 2700 };
static const uint16_t high_harmonics[]   = { 3500 };

// RTOS objects
static OS_TMR *toneTmr;
static OS_TMR *spaceTmr;
static OS_TMR *interBurstTmr;
static OS_SEM buzzerSem;

// Task stack and control block
static CPU_STK buzzer_task_stack[BUZZER_TASK_STACK_SIZE];
static OS_TCB  buzzer_task_tcb;

// Private functions
static void set_pwm_frequency(uint16_t freq);
static void stop_pwm(void);
static void ToneTimeout(void *p_arg);
static void AlarmTimeout(void *p_arg);
static void BuzzerTask(void *p_arg);

/**
  * @brief  Sets PWM frequency for buzzer
  * @param  freq: Frequency in Hz
  */
static void set_pwm_frequency(uint16_t freq)
{
    uint32_t timer_clk = HAL_RCC_GetPCLK1Freq() * 2;
    uint32_t period = (timer_clk / freq) - 1;
    
    __HAL_TIM_SET_PRESCALER(alarm_htim, 0);
    __HAL_TIM_SET_AUTORELOAD(alarm_htim, period);
    __HAL_TIM_SET_COMPARE(alarm_htim, ALARM_TIMER_CHANNEL, period / 2);
    HAL_TIM_PWM_Start(alarm_htim, ALARM_TIMER_CHANNEL);
}

/**
  * @brief  Stops PWM output
  */
static void stop_pwm(void)
{
    HAL_TIM_PWM_Stop(alarm_htim, ALARM_TIMER_CHANNEL);
}

/**
  * @brief  Callback for tone timer expiration
  */
static void ToneTimeout(void *p_arg)
{
    (void)p_arg;
    stop_pwm();
}

/**
  * @brief  Callback for alarm stop timer expiration
  */
static void AlarmTimeout(void *p_arg)
{
    (void)p_arg;
    Alarm_Stop();
}

/**
  * @brief  Main buzzer task handling alarm patterns
  */
static void BuzzerTask(void *p_arg)
{
    OS_ERR err;
    (void)p_arg;

    while (1) {
        // Wait for activation signal
        OSSemPend(&buzzerSem, 0, OS_OPT_PEND_BLOCKING, 0, &err);

        // Process current alarm pattern
        while (current_priority != ALARM_PRIORITY_NONE) {
            switch (state) {
                case STATE_IDLE:
                    pulseIndex = 0;
                    state = STATE_PLAYING;
                    break;

                case STATE_PLAYING:
                    if (current_priority == ALARM_PRIORITY_LOW) {
                        set_pwm_frequency(low_harmonics[0]);
                        toneTmr->OSTmrMatch = OSTimeGet(&err) + 50;
                        OSTmrStart(toneTmr, &err);
                        state = STATE_IDLE;
                    } 
                    else if (current_priority == ALARM_PRIORITY_MEDIUM) {
                        set_pwm_frequency(medium_harmonics[pulseIndex]);
                        toneTmr->OSTmrMatch = OSTimeGet(&err) + 25;
                        OSTmrStart(toneTmr, &err);
                        state = STATE_SPACING;
                    } 
                    else if (current_priority == ALARM_PRIORITY_HIGH) {
                        set_pwm_frequency(high_harmonics[0]);
                        toneTmr->OSTmrMatch = OSTimeGet(&err) + 10;
                        OSTmrStart(toneTmr, &err);
                        state = STATE_SPACING;
                    }
                    break;

                case STATE_SPACING:
                    if (current_priority == ALARM_PRIORITY_MEDIUM) {
                        spaceTmr->OSTmrMatch = OSTimeGet(&err) + 25;
                        OSTmrStart(spaceTmr, &err);
                        pulseIndex++;
                        if (pulseIndex >= sizeof(medium_harmonics)/sizeof(uint16_t)) {
                            pulseIndex = 0;
                            state = STATE_INTER_BURST;
                        } else {
                            state = STATE_PLAYING;
                        }
                    } 
                    else if (current_priority == ALARM_PRIORITY_HIGH) {
                        spaceTmr->OSTmrMatch = OSTimeGet(&err) + 10;
                        OSTmrStart(spaceTmr, &err);
                        state = STATE_PLAYING;
                    }
                    break;

                case STATE_INTER_BURST:
                    interBurstTmr->OSTmrMatch = OSTimeGet(&err) + 150;
                    OSTmrStart(interBurstTmr, &err);
                    state = STATE_PLAYING;
                    break;
            }
            OSTimeDly(10, OS_OPT_TIME_DLY, &err);
        }
    }
}

/**
  * @brief  Initializes alarm audio subsystem
  * @param  htim: Pointer to initialized TIM handle
  */
void Alarm_Init(TIM_HandleTypeDef *htim)
{
    OS_ERR err;
    
    // Validate parameters
    if (htim == NULL) {
        return;
    }
    
    // Store hardware reference
    alarm_htim = htim;
    
    // Create synchronization semaphore
    OSSemCreate(&buzzerSem, "Buzzer Sem", 0, &err);
    
    // Create timers
    toneTmr = OSTmrCreate(50, 25, OS_TMR_OPT_ONE_SHOT, 
                         (OS_TMR_CALLBACK)ToneTimeout, NULL, "Tone Timer", &err);
    
    spaceTmr = OSTmrCreate(25, 25, OS_TMR_OPT_ONE_SHOT, 
                          NULL, NULL, "Space Timer", &err);
    
    interBurstTmr = OSTmrCreate(150, 150, OS_TMR_OPT_ONE_SHOT, 
                               NULL, NULL, "Burst Timer", &err);
    
    // Create buzzer task
    OSTaskCreate(&buzzer_task_tcb,
                "Buzzer Task",
                BuzzerTask,
                NULL,
                BUZZER_TASK_PRIORITY,
                &buzzer_task_stack[0],
                BUZZER_TASK_STACK_SIZE / 10,
                BUZZER_TASK_STACK_SIZE,
                0,
                0,
                NULL,
                OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR,
                &err);
}

/**
  * @brief  Starts alarm with specified priority
  * @param  priority: Alarm priority level
  */
void Alarm_Start(AlarmPriority_t priority)
{
    OS_ERR err;
    
    if (priority == ALARM_PRIORITY_NONE) {
        return;
    }
    
    if (current_priority == ALARM_PRIORITY_NONE) {
        current_priority = priority;
        OSSemPost(&buzzerSem, OS_OPT_POST_1, &err);
    }
}

/**
  * @brief  Stops currently playing alarm
  */
void Alarm_Stop(void)
{
    OS_ERR err;
    
    if (current_priority == ALARM_PRIORITY_NONE) {
        return;
    }
    
    stop_pwm();
    current_priority = ALARM_PRIORITY_NONE;
    state = STATE_IDLE;
    pulseIndex = 0;

    OSTmrStop(toneTmr, &err); 
    OSTmrStop(spaceTmr, &err); 
    OSTmrStop(interBurstTmr, &err); 
}