#include <stdint.h>
#include "glcd.h"   // <-- low-level functions (GLCD_DataWrite, GLCD_CommandWrite, etc.)

#define GLCD_WIDTH        240
#define GLCD_HEIGHT       64
#define GLCD_PAGES        (GLCD_HEIGHT / 8)   // 64/8 = 8 pages
#define BYTES_PER_ROW     GLCD_WIDTH

// ------------------------------------------------------
// Print an image (bitmap) on GLCD
// dat1[][] should be organized as [pages][width]
// Example for 240x64: dat1[8][240]
// ------------------------------------------------------
void GLCD_printImage(uint8_t length, uint8_t width,
                     const uint8_t dat1[length][width],
                     uint8_t horizontal_pos,
                     uint8_t vertical_pos)
{
    uint16_t addr;

    // Loop through rows (pages = groups of 8 vertical pixels)
    for (uint8_t n = 0; n < length; n++)
    {
        // Calculate base address for this row
        addr = G_BASE + ((vertical_pos + n) * BYTES_PER_ROW) + horizontal_pos;
        GLCD_setAddressByte(addr);

        uint32_t image = 0;   // use 32-bit to safely hold 4 packed bytes
        uint16_t loop_count = 0;

        // Loop through columns
        for (uint8_t m = 0; m < width; m++)
        {
            // Pack 4 pixels into image
            image = (image << 6) | dat1[n][m];

            if ((m & 0x03) == 3)   // every 4 pixels
            {
                // Write out 3 bytes
                for (int i = 3; i > 0; i--)
                {
                    GLCD_DataWrite((image >> (8 * (i - 1))) & 0xFF);
                    GLCD_CommandWrite(0xC0);   // write data & increment address
                    loop_count++;
                }
                image = 0;
            }
        }

        // Fill rest of row if needed
        while (loop_count < BYTES_PER_ROW)
        {
            GLCD_CommandWrite(0xC1);   // skip to next address
            loop_count++;
        }
    }

    // Final command
    GLCD_CommandWrite(0xC0);
}