#ifndef __KEYPAD_UCOS_H__
#define __KEYPAD_UCOS_H__

#include <os.h>
#include <cpu.h>
#include <stm32f4xx_hal.h>

#define KEYPAD_DEBOUNCE_TICKS    10u    /* Debounce time in OS ticks */
#define KEYPAD_QUEUE_SIZE        10u    /* Size of key event queue */

typedef enum {
    KEY_NONE = 0,
    KEY_M11,
    KEY_M2,
    KEY_M3,
    KEY_M4,
    KEY_MENU,
    KEY_CURSOR,
    KEY_ENT_HLP,
    KEY_C1,
    KEY_C2,
    KEY_C3,
    KEY_C4,
    KEY_ENT
} KeypadKey_t;

typedef struct {
    KeypadKey_t key;
    CPU_TS      ts;     /* Timestamp when key was pressed */
} KeypadEvent_t;

void     Keypad_Init(OS_ERR *p_err);
void     Keypad_Start(OS_ERR *p_err);
KeypadKey_t Keypad_GetKey(OS_TICK timeout, OS_ERR *p_err);
void     Keypad_ISR_Handler(uint16_t GPIO_Pin);

#endif /* __KEYPAD_UCOS_H__ */

#include "keypad_ucos.h"
#include "stm32f4xx_it.h"

/* Static variables */
static OS_Q       KeypadQ;
static OS_MUTEX   KeypadMutex;
static OS_FLAG_GRP KeypadFlags;

/* Keypad pin definitions */
#define COL_PORT GPIOD
#define COL1_PIN GPIO_PIN_0
#define COL2_PIN GPIO_PIN_1
#define COL3_PIN GPIO_PIN_2
#define COL4_PIN GPIO_PIN_3

#define ROW_PORT GPIOG
#define MENU_PIN GPIO_PIN_2
#define CURSOR_PIN GPIO_PIN_1
#define ENT_HLP_PIN GPIO_PIN_0

/* Key mapping */
static const KeypadKey_t keymap[3][4] = {
    {KEY_M11,    KEY_M2,     KEY_M3,     KEY_M4},
    {KEY_MENU,   KEY_CURSOR, KEY_ENT_HLP, KEY_NONE},
    {KEY_C1,     KEY_C2,     KEY_C3,     KEY_C4}
};

/* Task function prototypes */
static void Keypad_Task(void *p_arg);

void Keypad_Init(OS_ERR *p_err) {
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    /* Initialize Micrium objects */
    OSFlagCreate(&KeypadFlags,
                "Keypad Flags",
                0,
                p_err);
    if (*p_err != OS_ERR_NONE) return;
    
    OSMutexCreate(&KeypadMutex,
                 "Keypad Mutex",
                  p_err);
    if (*p_err != OS_ERR_NONE) return;
    
    OSQCreate(&KeypadQ,
             "Keypad Queue",
              KEYPAD_QUEUE_SIZE,
              p_err);
    if (*p_err != OS_ERR_NONE) return;
    
    /* Enable GPIO clocks */
    __HAL_RCC_GPIOD_CLK_ENABLE();
    __HAL_RCC_GPIOG_CLK_ENABLE();
    
    /* Configure column pins as outputs (open-drain) */
    GPIO_InitStruct.Pin = COL1_PIN | COL2_PIN | COL3_PIN | COL4_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(COL_PORT, &GPIO_InitStruct);
    
    /* Configure row pins as inputs with pull-up and interrupts */
    GPIO_InitStruct.Pin = MENU_PIN | CURSOR_PIN | ENT_HLP_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(ROW_PORT, &GPIO_InitStruct);
    
    /* Set all columns to high (inactive) */
    HAL_GPIO_WritePin(COL_PORT, COL1_PIN | COL2_PIN | COL3_PIN | COL4_PIN, GPIO_PIN_SET);
    
    /* Configure and enable EXTI interrupts */
    HAL_NVIC_SetPriority(EXTI2_IRQn, 0, 0); /* MENU (PG2) -> EXTI2 */
    HAL_NVIC_EnableIRQ(EXTI2_IRQn);
    
    HAL_NVIC_SetPriority(EXTI1_IRQn, 0, 0); /* CURSOR (PG1) -> EXTI1 */
    HAL_NVIC_EnableIRQ(EXTI1_IRQn);
    
    HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0); /* ENT/HLP (PG0) -> EXTI0 */
    HAL_NVIC_EnableIRQ(EXTI0_IRQn);
}

void Keypad_Start(OS_ERR *p_err) {
    OSTaskCreate(&KeypadTCB,
                "Keypad Task",
                 Keypad_Task,
                0,
                KEYPAD_TASK_PRIO,
                &KeypadStk[0],
                KEYPAD_TASK_STK_SIZE / 10,
                KEYPAD_TASK_STK_SIZE,
                0,
                0,
                0,
                (OS_OPT_TASK_STK_CLR | OS_OPT_TASK_STK_CHK),
                p_err);
}

static void Keypad_Task(void *p_arg) {
    OS_ERR      err;
    KeypadEvent_t event;
    CPU_TS      ts;
    
    (void)p_arg;
    
    while (DEF_TRUE) {
        /* Wait for key press flag */
        (void)OSFlagPend(&KeypadFlags,
                         KEYPAD_FLAG_KEY_PRESSED,
                         KEYPAD_DEBOUNCE_TICKS,
                         OS_OPT_PEND_FLAG_SET_ANY + OS_OPT_PEND_FLAG_CONSUME,
                         &ts,
                         &err);
        
        if (err == OS_ERR_NONE) {
            /* Get the pressed key */
            OSMutexPend(&KeypadMutex, 0, OS_OPT_PEND_BLOCKING, 0, &err);
            KeypadKey_t key = Keypad_Scan();
            OSMutexPost(&KeypadMutex, OS_OPT_POST_NONE, &err);
            
            if (key != KEY_NONE) {
                /* Create event and post to queue */
                event.key = key;
                event.ts = ts;
                
                OSQPost(&KeypadQ,
                       &event,
                        sizeof(KeypadEvent_t),
                        OS_OPT_POST_FIFO,
                        &err);
            }
        }
    }
}

KeypadKey_t Keypad_GetKey(OS_TICK timeout, OS_ERR *p_err) {
    KeypadEvent_t *p_event;
    KeypadKey_t    key = KEY_NONE;
    
    p_event = OSQPend(&KeypadQ,
                      timeout,
                      OS_OPT_PEND_BLOCKING,
                      sizeof(KeypadEvent_t),
                      0,
                      p_err);
    
    if (*p_err == OS_ERR_NONE) {
        key = p_event->key;
    }
    
    return key;
}

KeypadKey_t Keypad_Scan(void) {
    GPIO_PinState rowState;
    uint8_t col;
    KeypadKey_t key = KEY_NONE;
    
    /* Check each column */
    for (col = 0; col < 4; col++) {
        /* Activate current column (set to low) */
        switch(col) {
            case 0: HAL_GPIO_WritePin(COL_PORT, COL1_PIN, GPIO_PIN_RESET); break;
            case 1: HAL_GPIO_WritePin(COL_PORT, COL2_PIN, GPIO_PIN_RESET); break;
            case 2: HAL_GPIO_WritePin(COL_PORT, COL3_PIN, GPIO_PIN_RESET); break;
            case 3: HAL_GPIO_WritePin(COL_PORT, COL4_PIN, GPIO_PIN_RESET); break;
        }
        
        /* Small delay for stabilization */
        OSTimeDly(1, OS_OPT_TIME_DLY, 0);
        
        /* Check each row */
        rowState = HAL_GPIO_ReadPin(ROW_PORT, MENU_PIN);
        if (rowState == GPIO_PIN_RESET) {
            key = keymap[0][col];
            break;
        }
        
        rowState = HAL_GPIO_ReadPin(ROW_PORT, CURSOR_PIN);
        if (rowState == GPIO_PIN_RESET) {
            key = keymap[1][col];
            break;
        }
        
        rowState = HAL_GPIO_ReadPin(ROW_PORT, ENT_HLP_PIN);
        if (rowState == GPIO_PIN_RESET) {
            key = keymap[2][col];
            break;
        }
        
        /* Deactivate current column (set to high) */
        switch(col) {
            case 0: HAL_GPIO_WritePin(COL_PORT, COL1_PIN, GPIO_PIN_SET); break;
            case 1: HAL_GPIO_WritePin(COL_PORT, COL2_PIN, GPIO_PIN_SET); break;
            case 2: HAL_GPIO_WritePin(COL_PORT, COL3_PIN, GPIO_PIN_SET); break;
            case 3: HAL_GPIO_WritePin(COL_PORT, COL4_PIN, GPIO_PIN_SET); break;
        }
    }
    
    /* Ensure all columns are deactivated */
    HAL_GPIO_WritePin(COL_PORT, COL1_PIN | COL2_PIN | COL3_PIN | COL4_PIN, GPIO_PIN_SET);
    
    return key;
}

void Keypad_ISR_Handler(uint16_t GPIO_Pin) {
    OS_ERR err;
    CPU_SR_ALLOC();
    
    CPU_CRITICAL_ENTER();
    OSFlagPost(&KeypadFlags,
               KEYPAD_FLAG_KEY_PRESSED,
               OS_OPT_POST_FLAG_SET,
               &err);
    CPU_CRITICAL_EXIT();
    
    /* Clear EXTI interrupt pending bit */
    switch(GPIO_Pin) {
        case GPIO_PIN_0: __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_0); break;
        case GPIO_PIN_1: __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_1); break;
        case GPIO_PIN_2: __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_2); break;
    }
}

#include "keypad_ucos.h"

void EXTI0_IRQHandler(void) {
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
}

void EXTI1_IRQHandler(void) {
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);
}

void EXTI2_IRQHandler(void) {
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
    Keypad_ISR_Handler(GPIO_Pin);
}

#include "keypad_ucos.h"

void AppTaskKeypad(void *p_arg) {
    OS_ERR err;
    KeypadKey_t key;
    
    /* Initialize keypad */
    Keypad_Init(&err);
    if (err != OS_ERR_NONE) {
        /* Handle error */
    }
    
    /* Start keypad task */
    Keypad_Start(&err);
    if (err != OS_ERR_NONE) {
        /* Handle error */
    }
    
    while (1) {
        /* Wait for key press with 100ms timeout */
        key = Keypad_GetKey(100, &err);
        
        if (err == OS_ERR_NONE) {
            switch(key) {
                case KEY_MENU:
                    /* Handle MENU key */
                    break;
                    
                case KEY_CURSOR:
                    /* Handle CURSOR key */
                    break;
                    
                case KEY_ENT_HLP:
                    /* Handle ENT/HLP key */
                    break;
                    
                /* Handle other keys */
                    
                default:
                    break;
            }
        } else if (err != OS_ERR_TIMEOUT) {
            /* Handle other errors */
        }
        
        /* Other task processing */
    }
}